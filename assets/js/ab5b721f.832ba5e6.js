"use strict";(self.webpackChunkobol_docs=self.webpackChunkobol_docs||[]).push([[6842],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return m}});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),d=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(r),m=i,f=p["".concat(s,".").concat(m)]||p[m]||u[m]||o;return r?n.createElement(f,a(a({ref:t},c),{},{components:r})):n.createElement(f,a({ref:t},c))}));function m(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=r.length,a=new Array(o);a[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var d=2;d<o;d++)a[d]=r[d];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},2297:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return c},default:function(){return p}});var n=r(7462),i=r(3366),o=(r(7294),r(3905)),a=["components"],l={description:"Deployment Architecture for a Distributed Validator Client"},s="Middleware daemon",d={unversionedId:"dv/middleware-daemon",id:"version-v0.3.0/dv/middleware-daemon",isDocsHomePage:!1,title:"Middleware daemon",description:"Deployment Architecture for a Distributed Validator Client",source:"@site/versioned_docs/version-v0.3.0/dv/04_middleware-daemon.md",sourceDirName:"dv",slug:"/dv/middleware-daemon",permalink:"/docs/dv/middleware-daemon",editUrl:"https://github.com/obolnetwork/obol-docs/edit/main/website/versioned_docs/version-v0.3.0/dv/04_middleware-daemon.md",tags:[],version:"v0.3.0",sidebarPosition:4,frontMatter:{description:"Deployment Architecture for a Distributed Validator Client"},sidebar:"version-v0.3.0/tutorialSidebar",previous:{title:"Distributed validator creation",permalink:"/docs/dv/validator-creation"},next:{title:"Peer discovery",permalink:"/docs/dv/peer-discovery"}},c=[{value:"Operation",id:"operation",children:[],level:3},{value:"Initialization",id:"initialization",children:[],level:3}],u={toc:c};function p(e){var t=e.components,r=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"middleware-daemon"},"Middleware daemon"),(0,o.kt)("p",null,"The Charon daemon serves as a consensus layer API middleware and connects to the Obol peer-to-peer network to discover it's counterpart Charon nodes."),(0,o.kt)("h3",{id:"operation"},"Operation"),(0,o.kt)("p",null,"The middleware strives to be stateless and statically configured through 777 file systems. The lack of a control-plane API for online reconfiguration is deliberate to keep operations simple and secure by default."),(0,o.kt)("p",null,"A single instance of the middleware can participate in multiple distributed validator clusters. The amount of validators per middleware is bound by risk management and hardware limits (CPU, memory, bandwidth), but there is no hardcoded limit."),(0,o.kt)("p",null,"The daemon offers a config reload instruction through Unix signals which is useful to join or leave Obol clusters on-the-fly without interruption."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"charon")," package will initially be available as a Docker image and through binary builds. An APT package with a systemd integration is planned."),(0,o.kt)("h3",{id:"initialization"},"Initialization"),(0,o.kt)("p",null,"An instance of Charon requires the following pieces of information at minimum in order to operate."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A DV cluster manifest file in the to be confirmed EIP format. This file contains the required information a DV client needs for joining a Distributed Validator Cluster. This file includes:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The total number of shares of the key and the required threshold for reconstruction."),(0,o.kt)("li",{parentName:"ul"},"An SECP256K1 key pair in an ENR format for Obol consensus messages, this key is signed by the corresponding operators validator key share to legitimise it."),(0,o.kt)("li",{parentName:"ul"},"A list of all ENR public keys of other operators participating in the cluster."),(0,o.kt)("li",{parentName:"ul"},"The group public keys representing each distributed validator in the cluster to the Ethereum network."))),(0,o.kt)("li",{parentName:"ul"},"Access to an Ethereum Consensus API",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"It is recommended to run at least one Ethereum Consensus client for each Charon middleware client."),(0,o.kt)("li",{parentName:"ul"},"Any ",(0,o.kt)("a",{parentName:"li",href:"https://ethereum.github.io/beacon-APIs/"},"compliant")," Beacon node implementation should work \u2013 try to establish client diversity."),(0,o.kt)("li",{parentName:"ul"},"These consensus clients need to be connected to at least one Ethereum Execution clients for block production."))),(0,o.kt)("li",{parentName:"ul"},"The public IP address and port the charon client will operate on",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"For now, we make the (naive) assumption that the address will be static."),(0,o.kt)("li",{parentName:"ul"},"Charon will attempt to auto-discover its address on first use by enumerating network interfaces and using ",(0,o.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc5389"},"STUN"),".")))))}p.isMDXComponent=!0}}]);